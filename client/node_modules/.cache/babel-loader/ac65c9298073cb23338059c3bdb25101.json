{"ast":null,"code":"const {\n  PACKET_TYPES_REVERSE,\n  ERROR_PACKET\n} = require(\"./commons\");\n\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nlet base64decoder;\n\nif (withNativeArrayBuffer) {\n  base64decoder = require(\"base64-arraybuffer\");\n}\n\nconst decodePacket = (encodedPacket, binaryType) => {\n  if (typeof encodedPacket !== \"string\") {\n    return {\n      type: \"message\",\n      data: mapBinary(encodedPacket, binaryType)\n    };\n  }\n\n  const type = encodedPacket.charAt(0);\n\n  if (type === \"b\") {\n    return {\n      type: \"message\",\n      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n    };\n  }\n\n  const packetType = PACKET_TYPES_REVERSE[type];\n\n  if (!packetType) {\n    return ERROR_PACKET;\n  }\n\n  return encodedPacket.length > 1 ? {\n    type: PACKET_TYPES_REVERSE[type],\n    data: encodedPacket.substring(1)\n  } : {\n    type: PACKET_TYPES_REVERSE[type]\n  };\n};\n\nconst decodeBase64Packet = (data, binaryType) => {\n  if (base64decoder) {\n    const decoded = base64decoder.decode(data);\n    return mapBinary(decoded, binaryType);\n  } else {\n    return {\n      base64: true,\n      data\n    }; // fallback for old browsers\n  }\n};\n\nconst mapBinary = (data, binaryType) => {\n  switch (binaryType) {\n    case \"blob\":\n      return data instanceof ArrayBuffer ? new Blob([data]) : data;\n\n    case \"arraybuffer\":\n    default:\n      return data;\n    // assuming the data is already an ArrayBuffer\n  }\n};\n\nmodule.exports = decodePacket;","map":{"version":3,"sources":["C:/Users/japot/Desktop/Peppermint/Peppermint/client/node_modules/engine.io-parser/lib/decodePacket.browser.js"],"names":["PACKET_TYPES_REVERSE","ERROR_PACKET","require","withNativeArrayBuffer","ArrayBuffer","base64decoder","decodePacket","encodedPacket","binaryType","type","data","mapBinary","charAt","decodeBase64Packet","substring","packetType","length","decoded","decode","base64","Blob","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA,oBAAF;AAAwBC,EAAAA;AAAxB,IAAyCC,OAAO,CAAC,WAAD,CAAtD;;AAEA,MAAMC,qBAAqB,GAAG,OAAOC,WAAP,KAAuB,UAArD;AAEA,IAAIC,aAAJ;;AACA,IAAIF,qBAAJ,EAA2B;AACzBE,EAAAA,aAAa,GAAGH,OAAO,CAAC,oBAAD,CAAvB;AACD;;AAED,MAAMI,YAAY,GAAG,CAACC,aAAD,EAAgBC,UAAhB,KAA+B;AAClD,MAAI,OAAOD,aAAP,KAAyB,QAA7B,EAAuC;AACrC,WAAO;AACLE,MAAAA,IAAI,EAAE,SADD;AAELC,MAAAA,IAAI,EAAEC,SAAS,CAACJ,aAAD,EAAgBC,UAAhB;AAFV,KAAP;AAID;;AACD,QAAMC,IAAI,GAAGF,aAAa,CAACK,MAAd,CAAqB,CAArB,CAAb;;AACA,MAAIH,IAAI,KAAK,GAAb,EAAkB;AAChB,WAAO;AACLA,MAAAA,IAAI,EAAE,SADD;AAELC,MAAAA,IAAI,EAAEG,kBAAkB,CAACN,aAAa,CAACO,SAAd,CAAwB,CAAxB,CAAD,EAA6BN,UAA7B;AAFnB,KAAP;AAID;;AACD,QAAMO,UAAU,GAAGf,oBAAoB,CAACS,IAAD,CAAvC;;AACA,MAAI,CAACM,UAAL,EAAiB;AACf,WAAOd,YAAP;AACD;;AACD,SAAOM,aAAa,CAACS,MAAd,GAAuB,CAAvB,GACH;AACEP,IAAAA,IAAI,EAAET,oBAAoB,CAACS,IAAD,CAD5B;AAEEC,IAAAA,IAAI,EAAEH,aAAa,CAACO,SAAd,CAAwB,CAAxB;AAFR,GADG,GAKH;AACEL,IAAAA,IAAI,EAAET,oBAAoB,CAACS,IAAD;AAD5B,GALJ;AAQD,CA1BD;;AA4BA,MAAMI,kBAAkB,GAAG,CAACH,IAAD,EAAOF,UAAP,KAAsB;AAC/C,MAAIH,aAAJ,EAAmB;AACjB,UAAMY,OAAO,GAAGZ,aAAa,CAACa,MAAd,CAAqBR,IAArB,CAAhB;AACA,WAAOC,SAAS,CAACM,OAAD,EAAUT,UAAV,CAAhB;AACD,GAHD,MAGO;AACL,WAAO;AAAEW,MAAAA,MAAM,EAAE,IAAV;AAAgBT,MAAAA;AAAhB,KAAP,CADK,CAC0B;AAChC;AACF,CAPD;;AASA,MAAMC,SAAS,GAAG,CAACD,IAAD,EAAOF,UAAP,KAAsB;AACtC,UAAQA,UAAR;AACE,SAAK,MAAL;AACE,aAAOE,IAAI,YAAYN,WAAhB,GAA8B,IAAIgB,IAAJ,CAAS,CAACV,IAAD,CAAT,CAA9B,GAAiDA,IAAxD;;AACF,SAAK,aAAL;AACA;AACE,aAAOA,IAAP;AAAa;AALjB;AAOD,CARD;;AAUAW,MAAM,CAACC,OAAP,GAAiBhB,YAAjB","sourcesContent":["const { PACKET_TYPES_REVERSE, ERROR_PACKET } = require(\"./commons\");\n\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n\nlet base64decoder;\nif (withNativeArrayBuffer) {\n  base64decoder = require(\"base64-arraybuffer\");\n}\n\nconst decodePacket = (encodedPacket, binaryType) => {\n  if (typeof encodedPacket !== \"string\") {\n    return {\n      type: \"message\",\n      data: mapBinary(encodedPacket, binaryType)\n    };\n  }\n  const type = encodedPacket.charAt(0);\n  if (type === \"b\") {\n    return {\n      type: \"message\",\n      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n    };\n  }\n  const packetType = PACKET_TYPES_REVERSE[type];\n  if (!packetType) {\n    return ERROR_PACKET;\n  }\n  return encodedPacket.length > 1\n    ? {\n        type: PACKET_TYPES_REVERSE[type],\n        data: encodedPacket.substring(1)\n      }\n    : {\n        type: PACKET_TYPES_REVERSE[type]\n      };\n};\n\nconst decodeBase64Packet = (data, binaryType) => {\n  if (base64decoder) {\n    const decoded = base64decoder.decode(data);\n    return mapBinary(decoded, binaryType);\n  } else {\n    return { base64: true, data }; // fallback for old browsers\n  }\n};\n\nconst mapBinary = (data, binaryType) => {\n  switch (binaryType) {\n    case \"blob\":\n      return data instanceof ArrayBuffer ? new Blob([data]) : data;\n    case \"arraybuffer\":\n    default:\n      return data; // assuming the data is already an ArrayBuffer\n  }\n};\n\nmodule.exports = decodePacket;\n"]},"metadata":{},"sourceType":"script"}